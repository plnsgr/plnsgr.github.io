---
title: "Ritsec CTF 2025 (Reverse)"
date: 2025-3-24
categories: [CTF]
tags: [CTF]
image: assets/CTF/ritsec-2025/ritsec2025.png
---

# Zogulon Traces

## Description
Quick!! Chase K has been abducted! He will surely be turned into a Zogulon if we don't find him in time. All I could find was this encoder for their hyperspace drive and this letter. There are likely clues everywhere, be meticulous!!

To the Terran Peoples
(UTC) Mar 17, 2025, 12:05:50 AM

The Zogulon Collective, has taken Chase K and transformed him into something beyond your understanding. He is lost to you now, never to return.

With indifference,
The Zogulon Collective


---

## Decompile

- Observing the decompile. The decompiled C code takes a user-provided string and obfuscates it using a transformation function, `glorbus_florbus()`, which applies a non-linear mathematical operation based on the index and a `random seed (time(0))`. The transformed bytes are then printed in hexadecimal format, along with the seed used for encoding. This essentially acts as a basic XOR-based encryption with a position-dependent key derived from the `glorbus_florbus()` function

- The flow of the program would be:

1. Read input string from the command line.
2. Generate a random seed using `time(0)`.
3. Allocate memory for encrypted output.
4. Loop through each character:
   - Compute transformation value using `glorbus_florbus(index, seed)`.
   - XOR character with this value.
5. Print encrypted hex output along with the seed.

- Below was the pseudocode in C of the original file:

```c
//----- (00000000000011A9) ----------------------------------------------------
__int64 __fastcall glorbus_florbus(int a1, unsigned int a2)
{
  return a1 * a1 * (a2 % 0xA + a1 - 5)
       + (a2 % 0xA + a1 - 3) * a1 * a1 * a1
       + (unsigned __int8)((a2 % 0xA + a1 - 7) * a1);
}

//----- (000000000000126A) ----------------------------------------------------
_BYTE *__fastcall squen_shorp(const char *a1, __int64 a2, unsigned int a3)
{
  _BYTE *result; // rax
  int i; // [rsp+28h] [rbp-8h]
  int v6; // [rsp+2Ch] [rbp-4h]

  v6 = strlen(a1);
  for ( i = 0; i < v6; ++i )
    *(_BYTE *)(i + a2) = a1[i] ^ glorbus_florbus(i, a3);
  result = (_BYTE *)(v6 + a2);
  *result = 0;
  return result;
}

//----- (00000000000012EF) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  size_t v4; // rax
  unsigned __int64 v5; // rax
  void *v6; // rsp
  size_t v7; // rbx
  _QWORD v8[2]; // [rsp+8h] [rbp-70h] BYREF
  const char **v9; // [rsp+18h] [rbp-60h]
  int v10; // [rsp+24h] [rbp-54h]
  int i; // [rsp+30h] [rbp-48h]
  unsigned int v12; // [rsp+34h] [rbp-44h]
  char *s; // [rsp+38h] [rbp-40h]
  size_t v14; // [rsp+40h] [rbp-38h]
  _QWORD *v15; // [rsp+48h] [rbp-30h]
  unsigned __int64 v16; // [rsp+50h] [rbp-28h]

  v10 = argc;
  v9 = argv;
  v16 = __readfsqword(0x28u);
  if ( argc > 1 )
  {
    s = (char *)v9[1];
    v4 = strlen(s) + 1;
    v14 = v4 - 1;
    v8[0] = v4;
    v8[1] = 0;
    v5 = 16 * ((v4 + 15) / 0x10);
    while ( v8 != (_QWORD *)((char *)v8 - (v5 & 0xFFFFFFFFFFFFF000LL)) )
      ;
    v6 = alloca(v5 & 0xFFF);
    if ( (v5 & 0xFFF) != 0 )
      *(_QWORD *)((char *)&v8[-1] + (v5 & 0xFFF)) = *(_QWORD *)((char *)&v8[-1] + (v5 & 0xFFF));
    v15 = v8;
    v12 = time(0);
    squen_shorp(s, (__int64)v15, v12);
    for ( i = 0; ; ++i )
    {
      v7 = i;
      if ( v7 >= strlen(s) )
        break;
      printf("%02x", *((unsigned __int8 *)v15 + i));
    }
    printf("\n: %08x\n", v12);
    return 0;
  }
  else
  {
    printf("Drinworg: %s <shwin>\n", *v9);
    return 1;
  }
}
```


## Dump from memory

- Dump the .TRACES_OF_THE_ZOGULAN and extract the hex of it:

```bash
└─$ objdump -s -j .TRACES_OF_THE_ZOGULAN hyperdrive_encoder.elf

hyperdrive_encoder.elf:     file format elf64-x86-64

Contents of section .TRACES_OF_THE_ZOGULAN:
 0000 52a799d1 13de948d fb5f59a9 c0480347  R........_Y..H.G
 0010 a1d1dc6a 84d8851d 6b21               ...j....k!
```

## Hash Generate

- Generate the time into hash

Python script:

```py
from datetime import datetime

timestamp = datetime(2025, 3, 17, 0, 5, 50)

seed = int(timestamp.timestamp())
print(hex(seed))
#0x67e012be
```

Output:

```bash
└─$ python hexfind.py
0x67e012be
```

Seed Hex: `0x67e012be`

## Reversing

- To reverses this process. By decoding a known encrypted message using the same `glorbus_florbus()` function. It will revert back the encoded hex string and a predefined seed, then XORs each byte with the corresponding transformed value to reconstruct the original text. This works because the encryption process is deterministic when given the same seed, allowing successful decryption if the correct seed is known.

- Decrypt process would be:

1. Read hex-encoded string and known seed.
2. Convert hex string to raw bytes.
3. Loop through each byte:
   - Compute the same transformation value.
   - XOR with the encoded byte to retrieve the original character.
4. Reconstruct and print the original message.

- decompile and make a script to decode it by reversing it:

```py
└─$ cat script.py
from datetime import datetime

def glorbus_florbus(a1, a2):
    return (
        a1 * a1 * (a2 % 0xA + a1 - 5)
        + (a2 % 0xA + a1 - 3) * a1 * a1 * a1
        + ((a2 % 0xA + a1 - 7) * a1)
    ) & 0xFF

def decode(encoded_hex, seed):
    encoded_bytes = bytes.fromhex(encoded_hex)
    decoded_bytes = []
    for i in range(len(encoded_bytes)):
        decoded_bytes.append(encoded_bytes[i] ^ glorbus_florbus(i, seed))
    return bytes(decoded_bytes).decode("utf-8", errors="replace")

def main():
    encoded_output = "52a799d113de948dfb5f59a9c0480347a1d1dc6a84d8851d6b21"
    seed = 0x67e012be
    decoded_message = decode(encoded_output, seed)
    print("Decoded Message:", decoded_message)

if __name__ == "__main__":
    main()
```

- The output will be:

```bash
└─$ python script.py
Decoded Message: RS{37.233333, -115.808333}
```

Flag: `RS{37.233333, -115.808333}`
